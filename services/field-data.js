'use strict';

var fc = require('@turf/helpers').featureCollection;
var map = require('lodash').map;
var groupBy = require('lodash').groupBy;

/**
 * @func groupGeometriesById
 * Given an array of objects that represent field data geometries,
 * returns an array of objects that, for each road ids, include road geometries grouped by source.
 * @param geoms {array} array of field data geometries generated by a knex query
 * @return {array} array of field data geometries grouped by VProMMsId
 */
exports.groupGeometriesById = function (geoms) {
  // first group geometries by road id (VProMMs id);
  // this top level grouping allows for the 'group by source' to be applied for each road id.
  geoms = groupBy(geoms, 'road_id');
  // for each road id group:
  //   1. take geometries and group them by source, either RoadLabPro or RouteShoot. (aka sourceGroup)
  //   2. take each source group and generate a feature collection (aka sourceGeometries)
  var groupedGeoms = map(geoms, (roadId ,k) => {
     // group road id geometries by their source
    let sourceGroup = groupBy(roadId, 'source');
    // for each source group, make a feature collection
    sourceGroup = map(sourceGroup, (sourceGeometry, i) => {
      // to make the feature collection, first transform each sourceGeometry into a feature.
      sourceGeometry = map(sourceGeometry, (sourceObj, j) => {
        // make properties object that includes the sourceObj's source name as well as the roadId
        let props = {properties: {source: sourceObj.source, vProMMsId: k}};
        // parse geometry string to a json
        let geom = { geometry: JSON.parse(sourceObj.geometry) };
        // return props and geom as a single object (mirroring a GeoJSON feature)
        return Object.assign(geom, props);
      });
      // after being passed through the map function, sourceGeometry is an array of GeoJSON features.
      // by passing it through turf's feature collection function, we turn it into a feature collection as needed
      return fc(sourceGeometry);
    });
    // finally, take sourceGroup, currently an array of sourceGeometry feature collections,
    // and generate roadObject. roadObject is an obj with a key=roadId, and property=sourceGroup.
    const roadObject = {};
    roadObject[k] = sourceGroup;
    return roadObject;
  });
  // returned groupedGeoms, a list of roadObjects
  return groupedGeoms;
};

/**
 * given a list objects with road geometries, id, and source, creates a feature class from the array
 * @func makeGeomFC
 * @param {array} geoms list of objects, each of which including a road geometry, its road id, and its source
 * @return {featureCollection} feature collection for roads.
 */
exports.makeGeomsFC = function (geoms) {
  // make features, a list of GeoJSON features, from the raw geoms array provided
  let features = map(geoms, (geom, k) => {
    // first parse the stringified feature geometry generated from the ST_ASGeoJSON() query used as part of the endpoint
    const geometry = { geometry: JSON.parse(geom.geometry) };
    // generate a properties object with the road_id and source provided too from the query
    const props = {properties:  {road_id: geom.road_id, source: geom.source}};
    // return a GeoJSON feature including both the geometry and properties
    return Object.assign(geometry, props);
  });
  // return this list of features passed through the turn feature collection function, which returns a feature collection
  return fc(features);
};


/**
 * given two arrays, one with road ids in the database, the other of road ids provided to an api query
 * returns an object where each key is a road id and its value is a boolean, true if the VProMMsId is in the db, false if not
 * @func mapExistingIds
 * @param {array} existingIds list of ids existing in the database
 * @param {array} ids list of ids provided to an api query
 * @return {object} object where key is a road id, and each property is a boolean (true if in the db, false if not)
 */
exports.mapExistingIds = function (existingIds, ids) {
  // initialize the ids object to serve as the response
  let idsObj = {};
  // transform list of ids into objects denoting if they exist in the database
  ids.forEach(id => {
    // isAnExistingId searches for `id` in the `existingids` list, then casts the search to a boolean. (true if found, false if not)
    const isAnExistingId = Boolean(existingIds.find(existingId => existingId.road_id === id));
    // add a key = the current id and a value = isAnExistingId for the current object
    idsObj[id] = isAnExistingId;
  });
  return idsObj;
};
